---
title: "Préparation de la liste d'arbres à vérifier"
author: "Nino PAGE"
date: "27 novembre 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
load("Paracou_basic_POM.RData")
library(tidyverse)
library(gtable)
```

# Introduction

La reconstitution des POMs à Paracou a mené à une exploration détaillée de la base de données. Face aux questions qui restent en suspens, telle que la fiabilité du code mesure ou du code échelle, et l'utilisation mutuellement exclusive ou non de ces deux champs pour renseigner les modalités de mesures, une vérification sur le terrain s'impose. Ce document synthétise uniquement la partie du travail visant à identifier et localiser les arbres encore vivants pour lesquels une vérification pourrait apporter des informations utiles à nos fins.

# Données de départ

## Paracou

Nous partons de la DB complète extraite avec EcoFoG::Paracou2df(), pour lesquelles les parcelles 1 à 16 ont été retenues.

```{r}
# titi <- reconstitute_POM(EcoFoG::Paracou2df())
# ou bien
# load("Paracou_basic_POM.RData")

titi <- titi %>% filter(Plot %in% 1:16) %>%  arrange(id,time)
```


## Reconstitution du champ POM

Le champ POM théorique a été reconstruit sous l'hypothèse nulle de totale fiabilité des codes mesure (cf. la fonction correspondante). Le code n'est pas inclut dans ce document, par souci de temps de calcul. La suite de l'exploration a notamment consisté à évaluer la fiabilité de ce champ, qui comporte manifestement quelques erreurs, que seule une vérifcation terrain permettra de mettre en évidence.

## Données échelle

La variable "Echelle" a été extraite, accompagnée des informations de base sur la localisation des individus, n'étant pas accessible dans le jeu de données obtenu via paracou2df().

## Nombres d'arbres concernés

### Tout confondu

On dénombre 2414 arbres encore vivants au dernier inventaire (2015 pour la P16, 2018 pour les parcelles témoins, 2017 pour les parcelles exploitées), ayant été tagué par un code mesure indiquant un réhaussement de POM au moins une fois durant le suivi.
```{r}
# Unique POM shift
titi$is_singlet <- titi$code %in% 1:3
titi$time_singlet <- ifelse(titi$is_singlet,
                            titi$time,
                            NA)

singlet_id <- titi %>% 
  filter(is_singlet & CodeAlive == 1 ) %>% 
  select(id) %>% 
  unique %>% pull

titi %>% 
  filter(id%in% singlet_id) %>% 
  select(Plot, time, id) %>%
  filter((Plot == 16 & time == 2015)|
           (Plot != 16 & time %in% c(2017,2018))) %>%
  select(id) %>% 
  unique %>% unique %>% nrow
```

### Uniques, paires et triples

Ayant supposé qu'une des mauvaises interprétation possible de l'utilisation du code mesure était de taguer un arbre avec un code 1 à 3 lors d'un changement de POM (temps $t$), et le re-taguer les années suivantes alors que le POM reste le même les années suivantes ($POM(t-dt)+ 0.5*code$), nous avons réalisé une première exploration consistant à évaluer la fréquence de ces cas, et comprendre leur structure. 

Nous avons mis en évidence que le code mesure, lorsqu'il indique un changement de POM, peut apparaître une seule fois, deux fois d'affilée (pour un même code) ou bien trois. Aucun cas ne comporte plus de trois répétitions d'un même code.

Pour optimiser le tag de ces individus, nous avons simplement utilisé des colonnes laguées (décalées de sorte à ce que $lag(col)[i] = col[i-1]$) afin de faire des tests logiques de manière vectorielle. 

```{r}
# Save the original information elsewhere
titi$code_copy <- titi$code
titi[which(!titi$code %in% c(1,2,3)),"code"] <- 0

titi$code_lag <- lag(titi$code)
titi$code_lag_two <- lag(titi$code_lag)


titi$time_lag <- lag(titi$time)
titi$time_lag_two <- lag(titi$time_lag)


titi$id_lag <- lag(titi$id)
titi$id_lag_two <- lag(titi$id_lag)
```

Nous allons jusqu'à deux lags seulement, ayant d'ores et déjà vérifié que le même code n'apparaissait jamais plus de trois inventaires successifs.

#### Triplets

Nous appellerons triplets les occurrences, pour un même individu, du même code durant trois inventaires successifs.

```{r}
#Repeated three times
titi$is_triplet <- titi$code == titi$code_lag &
  titi$code == titi$code_lag_two &
  titi$code %in% 1:3 &
  titi$id == titi$id_lag &
  titi$id == titi$id_lag_two

titi$time_triplet <- ifelse(titi$is_triplet & !titi$time%in%c(1,2),
                            paste(titi$time_lag_two,titi$time,sep = "_"),
                            NA)
```


#### Vrais duets

Nous appellerons duets deux occurrences successives d'un même code mesure pour un même individu. Ici, il a fallu différencier les "vrais" duets des "faux" dûs à la présence de triplets : Si deux duets se suivent, (donc, si il s'agit d'un triplet), nous ne les comptabilisons pas.


```{r}
titi$is_duet <- titi$code == titi$code_lag &
  titi$code %in% 1:3 &
  titi$id == titi$id_lag
# sum(titi$is_duet)
titi$time_duet <- ifelse(titi$is_duet & titi$time != 1,
                            paste(titi$time_lag,titi$time,sep = "_"),
                            NA)

titi$is_duet_lag <- lag(titi$is_duet)
titi$is_duet_lead <- lead(titi$is_duet)

titi$real_duets <- titi$is_duet
# titi$real_duets[-1] <- titi$is_duet[-1] & titi$is_duet[-1]!=titi$is_duet_lag[-1]
# any(titi$is_duet[-1]&titi$is_duet_lag[-1])


titi$real_duets[which(titi$is_duet&titi$is_duet_lag)] <- F
titi$real_duets[which(titi$is_duet&titi$is_duet_lead)] <- F
# identical(titi$real_duets,titi$is_duet)

titi$time_real_duets = ifelse(titi$real_duets, titi$time_duet, NA)

# titi$real_duets %>% sum
```

#### Vrais singlets

```{r}
titi$is_singlet_lag <- lag(titi$is_singlet)
titi$is_singlet_lead <- lead(titi$is_singlet)
titi$code_lead <- lead(titi$code)

titi$real_singlets <- titi$is_singlet
titi$real_singlets_omit <- titi$is_singlet
titi$real_singlets_omit[which(titi$is_singlet & 
                           titi$is_singlet_lag == titi$is_singlet)] <- FALSE
titi$real_singlets[which(titi$is_singlet &
                           titi$is_singlet_lag == titi$is_singlet &
                           titi$code_lag == titi$code)] <- FALSE
titi$real_singlets_omit[which(titi$is_singlet &
                           titi$is_singlet_lead == titi$is_singlet)] <- FALSE

titi$real_singlets[which(titi$is_singlet &
                           titi$is_singlet_lead == titi$is_singlet &
                           titi$code_lead == titi$code)] <- FALSE

titi$time_real_singlets <- ifelse(titi$real_singlets, titi$time_singlet, NA)
```


#### Comptes
```{r}

singlet_id <- titi %>% 
  filter(is_singlet & CodeAlive == 1 ) %>% 
  select(id) %>% 
  unique %>% pull

singlet_all <- titi %>% 
  filter(id%in% singlet_id) %>% 
  select(Plot, time, id) %>%
  filter((Plot == 16 & time == 2015)|
           (Plot != 16 & time %in% c(2017,2018))) %>%
  select(id) %>% 
  unique %>% pull

singlet_all_omit <- titi %>% 
  filter(id%in% singlet_id) %>% 
  select(Plot, time, id) %>%
  filter((Plot == 16 & time == 2015)|
           (Plot != 16 & time %in% c(2017,2018))) %>%
  select(id) %>% 
  unique %>% pull

real_singlet_id <- titi %>% 
  filter(real_singlets == 1 & CodeAlive == 1 ) %>% 
  select(id) %>% 
  unique %>% pull

singlet_check <- titi %>% 
  filter(id%in% real_singlet_id) %>% 
  select(Plot, time, id) %>%
  filter((Plot == 16 & time == 2015)|
           (time %in% c(2017,2018))) %>%
  select(id) %>% 
  unique %>% pull

duet_id <- titi %>% 
  filter(real_duets & CodeAlive == 1 ) %>% 
  select(id) %>% 
  unique %>% pull

duet_check <- titi %>% 
  filter(id%in% duet_id) %>% 
  select(Plot, time, id) %>%
  filter((Plot == 16 & time == 2015)|
           (time %in% c(2017,2018))) %>%
  select(id) %>% 
  unique %>% pull

triplet_id <- titi %>% 
  filter(is_triplet & CodeAlive == 1 ) %>% 
  select(id) %>% 
  unique %>% pull

triplet_check <- titi %>% 
  filter(id%in% triplet_id) %>% 
  select(Plot, time, id) %>%
  filter((Plot == 16 & time == 2015)|
           (time %in% c(2017,2018))) %>%
  select(id) %>% 
  unique %>% pull

tot <- c(singlet_check,duet_check,triplet_check) %>% unique 
idmiss <- singlet_all_omit[which(!singlet_all %in% tot)]
sel <- c("Plot","id","measure","time","CodeAlive","code","POM","Species","is_singlet","real_singlets","is_duet","real_duets","is_triplet")
sel %in% names(titi)
data <- titi[,sel]
data[data$id %in% idmiss & data$is_singlet,]
```


### Limites

N'ont pas été explorés les cas un peu plus fins, tels que celui où deux codes différents se suivent, ou bien où deux mêmes codes se suivent à quelques inventaires d'écart, ayant supposé que ceux-ci étaient rares et pour leur majorité non suspects. Il y a cependant un cas où des changements de POM indiqués isolément mènent à calculer un POM théorique de 7.3m, ce qui est impossible compte tenu de la taille de l'échelle avec laquelle les forestiers mesurent les arbres.
